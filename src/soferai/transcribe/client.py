# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from .types.transcription_request_info import TranscriptionRequestInfo
from ..core.request_options import RequestOptions
from .types.transcription_id import TranscriptionId
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.pydantic_utilities import parse_obj_as
from .errors.authentication_error import AuthenticationError
from .errors.rate_limit_error import RateLimitError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
import uuid
from .types.batch_audio_source import BatchAudioSource
from .types.processing_mode import ProcessingMode
from .types.batch_transcription_response import BatchTranscriptionResponse
from .types.batch_file_content_type import BatchFileContentType
from .types.batch_file_metadata import BatchFileMetadata
from .types.batch_file_upload_response import BatchFileUploadResponse
from .types.list_batch_files_response import ListBatchFilesResponse
from .types.batch_file_detail import BatchFileDetail
from ..core.jsonable_encoder import jsonable_encoder
from .errors.batch_not_found import BatchNotFound
from .types.batch_status_response import BatchStatusResponse
from .types.transcription_info import TranscriptionInfo
from .errors.transcription_not_found import TranscriptionNotFound
from .types.transcription import Transcription
from .types.transcription_summary import TranscriptionSummary
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TranscribeClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def create_transcription(
        self,
        *,
        info: TranscriptionRequestInfo,
        audio_url: typing.Optional[str] = OMIT,
        audio_file: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TranscriptionId:
        """
        Create a new transcription

        Parameters
        ----------
        info : TranscriptionRequestInfo
            Transcription parameters

        audio_url : typing.Optional[str]
            URL to a downloadable audio file. Must be a direct link to the file (not a streaming or preview link). If the URL is not directly downloadable, consider using our Link API to extract a downloadable link from supported sites. Either audio_url or audio_file must be provided, but not both.

        audio_file : typing.Optional[str]
            Base64 encoded audio file content. Either audio_url or audio_file must be provided, but not both.

            ## Base64 Encoding Example

            **Python:**
            ```python
            import base64
            from soferai import SoferAI

            # Initialize client
            client = SoferAI(api_key="your_api_key_here")

            # Read and encode audio file
            with open("audio.mp3", "rb") as f:
                base64_audio = base64.b64encode(f.read()).decode('utf-8')

            # Create transcription request
            response = client.transcribe.create_transcription(
                audio_file=base64_audio,
                info={
                    "model": "v1",
                    "primary_language": "en",
                    "hebrew_word_format": ["he"],
                    "title": "My Shiur Transcription"
                }
            )

            print(f"Transcription ID: {response}")
            ```

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TranscriptionId
            The unique identifier for the newly created transcription.
            Use this ID to check the status of the transcription or to retrieve the transcription result.

        Examples
        --------
        from soferai import SoferAI
        from soferai.transcribe import TranscriptionRequestInfo

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.transcribe.create_transcription(
            info=TranscriptionRequestInfo(),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/transcriptions/",
            method="POST",
            json={
                "audio_url": audio_url,
                "audio_file": audio_file,
                "info": convert_and_respect_annotation_metadata(
                    object_=info, annotation=TranscriptionRequestInfo, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TranscriptionId,
                    parse_obj_as(
                        type_=TranscriptionId,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_batch_transcription(
        self,
        *,
        info: TranscriptionRequestInfo,
        batch_file_id: typing.Optional[uuid.UUID] = OMIT,
        audio_sources: typing.Optional[typing.Sequence[BatchAudioSource]] = OMIT,
        batch_title: typing.Optional[str] = OMIT,
        batch_id: typing.Optional[uuid.UUID] = OMIT,
        processing_mode: typing.Optional[ProcessingMode] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchTranscriptionResponse:
        """
        Create multiple transcriptions to be processed in batch

        Parameters
        ----------
        info : TranscriptionRequestInfo
            Shared transcription parameters for all audio files in the batch

        batch_file_id : typing.Optional[uuid.UUID]
            Batch file to process in standard mode. Required when processing_mode is "standard"; not allowed when processing_mode is "express".

        audio_sources : typing.Optional[typing.Sequence[BatchAudioSource]]
            List of audio sources to transcribe with the same settings. Only allowed when processing_mode is "express"; not allowed when processing_mode is "standard".

        batch_title : typing.Optional[str]
            Optional title for the batch. The system will first check for a title in the Audio Source itself. If no title is provided there, it defaults to batch title providded here with "- Batch Item N" appended.

        batch_id : typing.Optional[uuid.UUID]
            Optional ID for the batch. If not provided, a UUID will be generated.

        processing_mode : typing.Optional[ProcessingMode]
            Processing speed and cost tier.
            - standard: (Default) Processed within 24 hours. Lower cost. Requires batch_file_id and disallows inline audio_sources.
            - express: Processed immediately. Higher cost. Limited to 10 files per batch. Requires inline audio_sources and disallows batch_file_id.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchTranscriptionResponse
            Information about the created batch including batch ID and individual transcription IDs.
            All transcriptions will be processed sequentially with delays between them.

        Examples
        --------
        from soferai import SoferAI
        from soferai.transcribe import TranscriptionRequestInfo

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.transcribe.create_batch_transcription(
            info=TranscriptionRequestInfo(),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/transcriptions/batch",
            method="POST",
            json={
                "batch_file_id": batch_file_id,
                "audio_sources": convert_and_respect_annotation_metadata(
                    object_=audio_sources, annotation=typing.Sequence[BatchAudioSource], direction="write"
                ),
                "info": convert_and_respect_annotation_metadata(
                    object_=info, annotation=TranscriptionRequestInfo, direction="write"
                ),
                "batch_title": batch_title,
                "batch_id": batch_id,
                "processing_mode": processing_mode,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchTranscriptionResponse,
                    parse_obj_as(
                        type_=BatchTranscriptionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def upload_batch_file(
        self,
        *,
        content_type: BatchFileContentType,
        json_items: typing.Optional[typing.Sequence[BatchAudioSource]] = OMIT,
        jsonl: typing.Optional[str] = OMIT,
        metadata: typing.Optional[BatchFileMetadata] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchFileUploadResponse:
        """
        Upload a batch manifest (JSON array or JSONL)

        Parameters
        ----------
        content_type : BatchFileContentType
            Format of the manifest payload. Use "json" for an array and "jsonl" for one JSON object per line separated by \n.

        json_items : typing.Optional[typing.Sequence[BatchAudioSource]]
            When content_type is "json", provide the items as an array. Mutually exclusive with jsonl.

        jsonl : typing.Optional[str]
            When content_type is "jsonl", provide the raw JSON Lines payload. One JSON object per line separated by \n. Mutually exclusive with json_items.

        metadata : typing.Optional[BatchFileMetadata]
            Optional metadata to associate with the uploaded batch file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchFileUploadResponse

        Examples
        --------
        from soferai import SoferAI

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.transcribe.upload_batch_file(
            content_type="json",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/transcriptions/batch-files",
            method="POST",
            json={
                "content_type": content_type,
                "json_items": convert_and_respect_annotation_metadata(
                    object_=json_items, annotation=typing.Sequence[BatchAudioSource], direction="write"
                ),
                "jsonl": jsonl,
                "metadata": convert_and_respect_annotation_metadata(
                    object_=metadata, annotation=BatchFileMetadata, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchFileUploadResponse,
                    parse_obj_as(
                        type_=BatchFileUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_batch_files(self, *, request_options: typing.Optional[RequestOptions] = None) -> ListBatchFilesResponse:
        """
        List uploaded batch files for the authenticated user

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListBatchFilesResponse

        Examples
        --------
        from soferai import SoferAI

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.transcribe.list_batch_files()
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/transcriptions/batch-files",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListBatchFilesResponse,
                    parse_obj_as(
                        type_=ListBatchFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_batch_file(
        self, batch_file_id: uuid.UUID, *, request_options: typing.Optional[RequestOptions] = None
    ) -> BatchFileDetail:
        """
        Get a single batch file's metadata and validation status

        Parameters
        ----------
        batch_file_id : uuid.UUID
            ID of the batch file

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchFileDetail

        Examples
        --------
        import uuid

        from soferai import SoferAI

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.transcribe.get_batch_file(
            batch_file_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/transcriptions/batch-files/{jsonable_encoder(batch_file_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchFileDetail,
                    parse_obj_as(
                        type_=BatchFileDetail,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise BatchNotFound()
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_batch_status(
        self, batch_id: uuid.UUID, *, request_options: typing.Optional[RequestOptions] = None
    ) -> BatchStatusResponse:
        """
        Get status of a batch transcription

        Parameters
        ----------
        batch_id : uuid.UUID
            ID of the batch. Use the ID returned from the Create Batch Transcription endpoint.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchStatusResponse

        Examples
        --------
        import uuid

        from soferai import SoferAI

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.transcribe.get_batch_status(
            batch_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/transcriptions/batch/{jsonable_encoder(batch_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchStatusResponse,
                    parse_obj_as(
                        type_=BatchStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise BatchNotFound()
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_transcription_status(
        self, transcription_id: uuid.UUID, *, request_options: typing.Optional[RequestOptions] = None
    ) -> TranscriptionInfo:
        """
        Get transcription status

        Parameters
        ----------
        transcription_id : uuid.UUID
            ID of the transcription. Use the ID returned from the Create Transcription endpoint.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TranscriptionInfo

        Examples
        --------
        import uuid

        from soferai import SoferAI

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.transcribe.get_transcription_status(
            transcription_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/transcriptions/{jsonable_encoder(transcription_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TranscriptionInfo,
                    parse_obj_as(
                        type_=TranscriptionInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise TranscriptionNotFound()
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_transcription(
        self,
        transcription_id: uuid.UUID,
        *,
        filter_hebrew_word_format: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Transcription:
        """
        Get transcription

        Parameters
        ----------
        transcription_id : uuid.UUID
            ID of the transcription. Use the ID returned from the Create Transcription endpoint.

        filter_hebrew_word_format : typing.Optional[str]
            Optionally filter the response to a single Hebrew word format. If set to 'en', the response text will have Hebrew characters removed and timestamps will exclude words tagged with 'he'. If set to 'he', italicized transliterations are removed from the text and timestamps will exclude words tagged only with 'en'. If set to 'hybrid', the response includes both transliteration and Hebrew characters for each word.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Transcription

        Examples
        --------
        import uuid

        from soferai import SoferAI

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.transcribe.get_transcription(
            transcription_id=uuid.UUID(
                "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/transcriptions/{jsonable_encoder(transcription_id)}",
            method="GET",
            params={
                "filter_hebrew_word_format": filter_hebrew_word_format,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Transcription,
                    parse_obj_as(
                        type_=Transcription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise TranscriptionNotFound()
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_transcriptions(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[TranscriptionSummary]:
        """
        Get all transcriptions for the authenticated user

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TranscriptionSummary]

        Examples
        --------
        from soferai import SoferAI

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.transcribe.list_transcriptions()
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/transcriptions/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TranscriptionSummary],
                    parse_obj_as(
                        type_=typing.List[TranscriptionSummary],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncTranscribeClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def create_transcription(
        self,
        *,
        info: TranscriptionRequestInfo,
        audio_url: typing.Optional[str] = OMIT,
        audio_file: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TranscriptionId:
        """
        Create a new transcription

        Parameters
        ----------
        info : TranscriptionRequestInfo
            Transcription parameters

        audio_url : typing.Optional[str]
            URL to a downloadable audio file. Must be a direct link to the file (not a streaming or preview link). If the URL is not directly downloadable, consider using our Link API to extract a downloadable link from supported sites. Either audio_url or audio_file must be provided, but not both.

        audio_file : typing.Optional[str]
            Base64 encoded audio file content. Either audio_url or audio_file must be provided, but not both.

            ## Base64 Encoding Example

            **Python:**
            ```python
            import base64
            from soferai import SoferAI

            # Initialize client
            client = SoferAI(api_key="your_api_key_here")

            # Read and encode audio file
            with open("audio.mp3", "rb") as f:
                base64_audio = base64.b64encode(f.read()).decode('utf-8')

            # Create transcription request
            response = client.transcribe.create_transcription(
                audio_file=base64_audio,
                info={
                    "model": "v1",
                    "primary_language": "en",
                    "hebrew_word_format": ["he"],
                    "title": "My Shiur Transcription"
                }
            )

            print(f"Transcription ID: {response}")
            ```

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TranscriptionId
            The unique identifier for the newly created transcription.
            Use this ID to check the status of the transcription or to retrieve the transcription result.

        Examples
        --------
        import asyncio

        from soferai import AsyncSoferAI
        from soferai.transcribe import TranscriptionRequestInfo

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transcribe.create_transcription(
                info=TranscriptionRequestInfo(),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/transcriptions/",
            method="POST",
            json={
                "audio_url": audio_url,
                "audio_file": audio_file,
                "info": convert_and_respect_annotation_metadata(
                    object_=info, annotation=TranscriptionRequestInfo, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TranscriptionId,
                    parse_obj_as(
                        type_=TranscriptionId,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_batch_transcription(
        self,
        *,
        info: TranscriptionRequestInfo,
        batch_file_id: typing.Optional[uuid.UUID] = OMIT,
        audio_sources: typing.Optional[typing.Sequence[BatchAudioSource]] = OMIT,
        batch_title: typing.Optional[str] = OMIT,
        batch_id: typing.Optional[uuid.UUID] = OMIT,
        processing_mode: typing.Optional[ProcessingMode] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchTranscriptionResponse:
        """
        Create multiple transcriptions to be processed in batch

        Parameters
        ----------
        info : TranscriptionRequestInfo
            Shared transcription parameters for all audio files in the batch

        batch_file_id : typing.Optional[uuid.UUID]
            Batch file to process in standard mode. Required when processing_mode is "standard"; not allowed when processing_mode is "express".

        audio_sources : typing.Optional[typing.Sequence[BatchAudioSource]]
            List of audio sources to transcribe with the same settings. Only allowed when processing_mode is "express"; not allowed when processing_mode is "standard".

        batch_title : typing.Optional[str]
            Optional title for the batch. The system will first check for a title in the Audio Source itself. If no title is provided there, it defaults to batch title providded here with "- Batch Item N" appended.

        batch_id : typing.Optional[uuid.UUID]
            Optional ID for the batch. If not provided, a UUID will be generated.

        processing_mode : typing.Optional[ProcessingMode]
            Processing speed and cost tier.
            - standard: (Default) Processed within 24 hours. Lower cost. Requires batch_file_id and disallows inline audio_sources.
            - express: Processed immediately. Higher cost. Limited to 10 files per batch. Requires inline audio_sources and disallows batch_file_id.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchTranscriptionResponse
            Information about the created batch including batch ID and individual transcription IDs.
            All transcriptions will be processed sequentially with delays between them.

        Examples
        --------
        import asyncio

        from soferai import AsyncSoferAI
        from soferai.transcribe import TranscriptionRequestInfo

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transcribe.create_batch_transcription(
                info=TranscriptionRequestInfo(),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/transcriptions/batch",
            method="POST",
            json={
                "batch_file_id": batch_file_id,
                "audio_sources": convert_and_respect_annotation_metadata(
                    object_=audio_sources, annotation=typing.Sequence[BatchAudioSource], direction="write"
                ),
                "info": convert_and_respect_annotation_metadata(
                    object_=info, annotation=TranscriptionRequestInfo, direction="write"
                ),
                "batch_title": batch_title,
                "batch_id": batch_id,
                "processing_mode": processing_mode,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchTranscriptionResponse,
                    parse_obj_as(
                        type_=BatchTranscriptionResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def upload_batch_file(
        self,
        *,
        content_type: BatchFileContentType,
        json_items: typing.Optional[typing.Sequence[BatchAudioSource]] = OMIT,
        jsonl: typing.Optional[str] = OMIT,
        metadata: typing.Optional[BatchFileMetadata] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchFileUploadResponse:
        """
        Upload a batch manifest (JSON array or JSONL)

        Parameters
        ----------
        content_type : BatchFileContentType
            Format of the manifest payload. Use "json" for an array and "jsonl" for one JSON object per line separated by \n.

        json_items : typing.Optional[typing.Sequence[BatchAudioSource]]
            When content_type is "json", provide the items as an array. Mutually exclusive with jsonl.

        jsonl : typing.Optional[str]
            When content_type is "jsonl", provide the raw JSON Lines payload. One JSON object per line separated by \n. Mutually exclusive with json_items.

        metadata : typing.Optional[BatchFileMetadata]
            Optional metadata to associate with the uploaded batch file.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchFileUploadResponse

        Examples
        --------
        import asyncio

        from soferai import AsyncSoferAI

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transcribe.upload_batch_file(
                content_type="json",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/transcriptions/batch-files",
            method="POST",
            json={
                "content_type": content_type,
                "json_items": convert_and_respect_annotation_metadata(
                    object_=json_items, annotation=typing.Sequence[BatchAudioSource], direction="write"
                ),
                "jsonl": jsonl,
                "metadata": convert_and_respect_annotation_metadata(
                    object_=metadata, annotation=BatchFileMetadata, direction="write"
                ),
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchFileUploadResponse,
                    parse_obj_as(
                        type_=BatchFileUploadResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_batch_files(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> ListBatchFilesResponse:
        """
        List uploaded batch files for the authenticated user

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListBatchFilesResponse

        Examples
        --------
        import asyncio

        from soferai import AsyncSoferAI

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transcribe.list_batch_files()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/transcriptions/batch-files",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListBatchFilesResponse,
                    parse_obj_as(
                        type_=ListBatchFilesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_batch_file(
        self, batch_file_id: uuid.UUID, *, request_options: typing.Optional[RequestOptions] = None
    ) -> BatchFileDetail:
        """
        Get a single batch file's metadata and validation status

        Parameters
        ----------
        batch_file_id : uuid.UUID
            ID of the batch file

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchFileDetail

        Examples
        --------
        import asyncio
        import uuid

        from soferai import AsyncSoferAI

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transcribe.get_batch_file(
                batch_file_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/transcriptions/batch-files/{jsonable_encoder(batch_file_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchFileDetail,
                    parse_obj_as(
                        type_=BatchFileDetail,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise BatchNotFound()
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_batch_status(
        self, batch_id: uuid.UUID, *, request_options: typing.Optional[RequestOptions] = None
    ) -> BatchStatusResponse:
        """
        Get status of a batch transcription

        Parameters
        ----------
        batch_id : uuid.UUID
            ID of the batch. Use the ID returned from the Create Batch Transcription endpoint.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchStatusResponse

        Examples
        --------
        import asyncio
        import uuid

        from soferai import AsyncSoferAI

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transcribe.get_batch_status(
                batch_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/transcriptions/batch/{jsonable_encoder(batch_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    BatchStatusResponse,
                    parse_obj_as(
                        type_=BatchStatusResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise BatchNotFound()
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_transcription_status(
        self, transcription_id: uuid.UUID, *, request_options: typing.Optional[RequestOptions] = None
    ) -> TranscriptionInfo:
        """
        Get transcription status

        Parameters
        ----------
        transcription_id : uuid.UUID
            ID of the transcription. Use the ID returned from the Create Transcription endpoint.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TranscriptionInfo

        Examples
        --------
        import asyncio
        import uuid

        from soferai import AsyncSoferAI

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transcribe.get_transcription_status(
                transcription_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/transcriptions/{jsonable_encoder(transcription_id)}/status",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    TranscriptionInfo,
                    parse_obj_as(
                        type_=TranscriptionInfo,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise TranscriptionNotFound()
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_transcription(
        self,
        transcription_id: uuid.UUID,
        *,
        filter_hebrew_word_format: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Transcription:
        """
        Get transcription

        Parameters
        ----------
        transcription_id : uuid.UUID
            ID of the transcription. Use the ID returned from the Create Transcription endpoint.

        filter_hebrew_word_format : typing.Optional[str]
            Optionally filter the response to a single Hebrew word format. If set to 'en', the response text will have Hebrew characters removed and timestamps will exclude words tagged with 'he'. If set to 'he', italicized transliterations are removed from the text and timestamps will exclude words tagged only with 'en'. If set to 'hybrid', the response includes both transliteration and Hebrew characters for each word.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Transcription

        Examples
        --------
        import asyncio
        import uuid

        from soferai import AsyncSoferAI

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transcribe.get_transcription(
                transcription_id=uuid.UUID(
                    "d5e9c84f-c2b2-4bf4-b4b0-7ffd7a9ffc32",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/transcriptions/{jsonable_encoder(transcription_id)}",
            method="GET",
            params={
                "filter_hebrew_word_format": filter_hebrew_word_format,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Transcription,
                    parse_obj_as(
                        type_=Transcription,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 404:
                raise TranscriptionNotFound()
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_transcriptions(
        self, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[TranscriptionSummary]:
        """
        Get all transcriptions for the authenticated user

        Parameters
        ----------
        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TranscriptionSummary]

        Examples
        --------
        import asyncio

        from soferai import AsyncSoferAI

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.transcribe.list_transcriptions()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/transcriptions/",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[TranscriptionSummary],
                    parse_obj_as(
                        type_=typing.List[TranscriptionSummary],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
