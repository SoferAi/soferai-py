# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..transcribe.types.timestamp import Timestamp
from .types.starting_phrase_topic import StartingPhraseTopic
from ..core.request_options import RequestOptions
from .types.aligned_starting_phrase import AlignedStartingPhrase
from ..core.serialization import convert_and_respect_annotation_metadata
from ..core.pydantic_utilities import parse_obj_as
from ..transcribe.errors.authentication_error import AuthenticationError
from ..transcribe.errors.rate_limit_error import RateLimitError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class TimestampsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def align_starting_phrases(
        self,
        *,
        transcript_words: typing.Sequence[Timestamp],
        topics: typing.Sequence[StartingPhraseTopic],
        monotone: typing.Optional[bool] = OMIT,
        conclusion_bias: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[AlignedStartingPhrase]:
        """
        Align topic starting phrases to timestamps within a transcript.

        To generate your own list of topics (StartingPhraseTopic), you can use a language model (LLM) with the following prompt:

            Below is a transcript of a shiur.
            You are an expert at structuring Jewish lectures (shiurim).
            Based on the following transcription, divide the content into logical chapters.
            Ensure that the chapter titles sound like a yeshiva student, relevant and human-like.

            For each chapter, provide:
            1.  A short, clear "title" based upon the content of that section. Should be in English. Up to 10 words.
            2.  The exact "starting_phrase" that begins the chapter. This needs to be the exact words that are in the document. Give at least 7 words.

            Return only valid JSON. Do NOT include any explanation.
            Transcript:
            {full_text}

        Replace `{full_text}` with your transcript. The model should return a JSON array of objects, each with a `title` and a `starting_phrase` (at least 7 words, exactly as they appear in the transcript).

        Example output:
            [
              {
                "title": "Introduction to the Topic",
                "starting_phrase": "Today we are going to discuss the laws of Shabbat"
              },
              {
                "title": "Historical Background",
                "starting_phrase": "In the times of the Talmud, the sages debated"
              }
            ]

        Use this output as the `topics` field in your request to this endpoint.

        Parameters
        ----------
        transcript_words : typing.Sequence[Timestamp]
            List of word-level timestamps for the transcript

        topics : typing.Sequence[StartingPhraseTopic]
            List of topics with their expected starting phrases

        monotone : typing.Optional[bool]
            If true, each topic is searched after the previous topic's start (with a small backoff)

        conclusion_bias : typing.Optional[bool]
            If true and a title includes the word "conclusion", search in the last third of the audio

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[AlignedStartingPhrase]

        Examples
        --------
        from soferai import SoferAI
        from soferai.timestamps import StartingPhraseTopic
        from soferai.transcribe import Timestamp

        client = SoferAI(
            api_key="YOUR_API_KEY",
        )
        client.timestamps.align_starting_phrases(
            transcript_words=[
                Timestamp(
                    word="word",
                    start=1.1,
                    end=1.1,
                ),
                Timestamp(
                    word="word",
                    start=1.1,
                    end=1.1,
                ),
            ],
            topics=[
                StartingPhraseTopic(
                    title="title",
                    starting_phrase="starting_phrase",
                ),
                StartingPhraseTopic(
                    title="title",
                    starting_phrase="starting_phrase",
                ),
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/timestamps/align-starting-phrases",
            method="POST",
            json={
                "transcript_words": convert_and_respect_annotation_metadata(
                    object_=transcript_words, annotation=typing.Sequence[Timestamp], direction="write"
                ),
                "topics": convert_and_respect_annotation_metadata(
                    object_=topics, annotation=typing.Sequence[StartingPhraseTopic], direction="write"
                ),
                "monotone": monotone,
                "conclusion_bias": conclusion_bias,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[AlignedStartingPhrase],
                    parse_obj_as(
                        type_=typing.List[AlignedStartingPhrase],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncTimestampsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def align_starting_phrases(
        self,
        *,
        transcript_words: typing.Sequence[Timestamp],
        topics: typing.Sequence[StartingPhraseTopic],
        monotone: typing.Optional[bool] = OMIT,
        conclusion_bias: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[AlignedStartingPhrase]:
        """
        Align topic starting phrases to timestamps within a transcript.

        To generate your own list of topics (StartingPhraseTopic), you can use a language model (LLM) with the following prompt:

            Below is a transcript of a shiur.
            You are an expert at structuring Jewish lectures (shiurim).
            Based on the following transcription, divide the content into logical chapters.
            Ensure that the chapter titles sound like a yeshiva student, relevant and human-like.

            For each chapter, provide:
            1.  A short, clear "title" based upon the content of that section. Should be in English. Up to 10 words.
            2.  The exact "starting_phrase" that begins the chapter. This needs to be the exact words that are in the document. Give at least 7 words.

            Return only valid JSON. Do NOT include any explanation.
            Transcript:
            {full_text}

        Replace `{full_text}` with your transcript. The model should return a JSON array of objects, each with a `title` and a `starting_phrase` (at least 7 words, exactly as they appear in the transcript).

        Example output:
            [
              {
                "title": "Introduction to the Topic",
                "starting_phrase": "Today we are going to discuss the laws of Shabbat"
              },
              {
                "title": "Historical Background",
                "starting_phrase": "In the times of the Talmud, the sages debated"
              }
            ]

        Use this output as the `topics` field in your request to this endpoint.

        Parameters
        ----------
        transcript_words : typing.Sequence[Timestamp]
            List of word-level timestamps for the transcript

        topics : typing.Sequence[StartingPhraseTopic]
            List of topics with their expected starting phrases

        monotone : typing.Optional[bool]
            If true, each topic is searched after the previous topic's start (with a small backoff)

        conclusion_bias : typing.Optional[bool]
            If true and a title includes the word "conclusion", search in the last third of the audio

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[AlignedStartingPhrase]

        Examples
        --------
        import asyncio

        from soferai import AsyncSoferAI
        from soferai.timestamps import StartingPhraseTopic
        from soferai.transcribe import Timestamp

        client = AsyncSoferAI(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.timestamps.align_starting_phrases(
                transcript_words=[
                    Timestamp(
                        word="word",
                        start=1.1,
                        end=1.1,
                    ),
                    Timestamp(
                        word="word",
                        start=1.1,
                        end=1.1,
                    ),
                ],
                topics=[
                    StartingPhraseTopic(
                        title="title",
                        starting_phrase="starting_phrase",
                    ),
                    StartingPhraseTopic(
                        title="title",
                        starting_phrase="starting_phrase",
                    ),
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/timestamps/align-starting-phrases",
            method="POST",
            json={
                "transcript_words": convert_and_respect_annotation_metadata(
                    object_=transcript_words, annotation=typing.Sequence[Timestamp], direction="write"
                ),
                "topics": convert_and_respect_annotation_metadata(
                    object_=topics, annotation=typing.Sequence[StartingPhraseTopic], direction="write"
                ),
                "monotone": monotone,
                "conclusion_bias": conclusion_bias,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[AlignedStartingPhrase],
                    parse_obj_as(
                        type_=typing.List[AlignedStartingPhrase],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 401:
                raise AuthenticationError()
            if _response.status_code == 429:
                raise RateLimitError()
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
